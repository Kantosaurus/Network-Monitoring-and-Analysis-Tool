/**
 * WiFi Penetration Testing Panel
 *
 * ‚ö†Ô∏è WARNING: For authorized security testing only!
 * Only test networks you own or have written authorization to test.
 *
 * Features:
 * - Network scanning with security analysis
 * - WPS vulnerability testing
 * - Handshake capture
 * - Password cracking
 * - Full automated attack workflow
 */

import React, { useState, useEffect } from 'react';
import './WiFiPentestingPanel.css';

interface Network {
  ssid: string;
  bssid: string;
  channel: number;
  signal_strength: number;
  security: string;
  encryption: string;
  wps: boolean;
  clients: number;
  security_analysis: {
    vulnerabilities: string[];
    recommendations: string[];
    risk_level: string;
  };
}

interface AttackResult {
  success: boolean;
  status: string;
  method?: string;
  password?: string;
  wps_pin?: string;
  duration?: number;
  error?: string;
  attempts?: any[];
}

const WiFiPentestingPanel: React.FC = () => {
  const [networks, setNetworks] = useState<Network[]>([]);
  const [selectedNetwork, setSelectedNetwork] = useState<Network | null>(null);
  const [isScanning, setIsScanning] = useState(false);
  const [isAttacking, setIsAttacking] = useState(false);
  const [attackStatus, setAttackStatus] = useState<string>('');
  const [attackResult, setAttackResult] = useState<AttackResult | null>(null);
  const [serverHealth, setServerHealth] = useState<any>(null);
  const [legalAcknowledged, setLegalAcknowledged] = useState(false);

  const API_BASE_URL = 'http://localhost:5001/api/pentesting';

  // Check server health
  useEffect(() => {
    checkHealth();
  }, []);

  const checkHealth = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/health`);
      const data = await response.json();
      setServerHealth(data);
    } catch (error) {
      console.error('Health check failed:', error);
    }
  };

  const scanNetworks = async () => {
    setIsScanning(true);
    setAttackResult(null);

    try {
      const response = await fetch(`${API_BASE_URL}/scan`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ duration: 10 })
      });

      const data = await response.json();

      if (data.success) {
        setNetworks(data.networks);
      } else {
        alert(`Scan failed: ${data.error}`);
      }
    } catch (error) {
      console.error('Scan error:', error);
      alert('Scan failed. Is the server running?');
    } finally {
      setIsScanning(false);
    }
  };

  const testWPS = async (network: Network) => {
    if (!legalAcknowledged) {
      alert('You must acknowledge the legal warning first!');
      return;
    }

    setIsAttacking(true);
    setAttackStatus('Testing WPS vulnerability (Pixie Dust)...');
    setAttackResult(null);

    try {
      const response = await fetch(`${API_BASE_URL}/wps-attack`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          bssid: network.bssid,
          ssid: network.ssid,
          channel: network.channel,
          attack_type: 'pixie_dust',
          timeout: 300
        })
      });

      const data = await response.json();
      setAttackResult(data);
      setAttackStatus('');
    } catch (error) {
      console.error('WPS attack error:', error);
      setAttackStatus('');
      alert('WPS attack failed');
    } finally {
      setIsAttacking(false);
    }
  };

  const captureHandshake = async (network: Network) => {
    if (!legalAcknowledged) {
      alert('You must acknowledge the legal warning first!');
      return;
    }

    setIsAttacking(true);
    setAttackStatus('Capturing WPA handshake (this may take a few minutes)...');
    setAttackResult(null);

    try {
      const response = await fetch(`${API_BASE_URL}/capture-handshake`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          bssid: network.bssid,
          ssid: network.ssid,
          channel: network.channel,
          timeout: 300,
          deauth: true,
          deauth_count: 10
        })
      });

      const data = await response.json();
      setAttackResult(data);

      if (data.success) {
        setAttackStatus('Handshake captured! Now cracking password...');
        // Automatically start cracking
        await crackPassword(data.capture_file, network);
      } else {
        setAttackStatus('');
      }
    } catch (error) {
      console.error('Handshake capture error:', error);
      setAttackStatus('');
      alert('Handshake capture failed');
    } finally {
      setIsAttacking(false);
    }
  };

  const crackPassword = async (captureFile: string, network: Network) => {
    setIsAttacking(true);
    setAttackStatus('Cracking password with dictionary attack (this may take a while)...');

    try {
      const response = await fetch(`${API_BASE_URL}/crack-password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          capture_file: captureFile,
          ssid: network.ssid,
          bssid: network.bssid,
          wordlist: '/usr/share/wordlists/rockyou.txt',
          attack_mode: 'dictionary',
          timeout: 3600
        })
      });

      const data = await response.json();
      setAttackResult(data);
      setAttackStatus('');
    } catch (error) {
      console.error('Password cracking error:', error);
      setAttackStatus('');
      alert('Password cracking failed');
    } finally {
      setIsAttacking(false);
    }
  };

  const fullAttack = async (network: Network) => {
    if (!legalAcknowledged) {
      alert('You must acknowledge the legal warning first!');
      return;
    }

    if (!confirm(
      `‚ö†Ô∏è WARNING: You are about to launch a full attack on:\n\n` +
      `SSID: ${network.ssid}\n` +
      `BSSID: ${network.bssid}\n\n` +
      `This will:\n` +
      `1. Test WPS vulnerabilities\n` +
      `2. Capture handshakes\n` +
      `3. Attempt dictionary attack\n\n` +
      `Only proceed if you have written authorization!\n\n` +
      `Continue?`
    )) {
      return;
    }

    setIsAttacking(true);
    setAttackStatus('Starting full automated attack...');
    setAttackResult(null);

    try {
      const response = await fetch(`${API_BASE_URL}/full-attack`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          bssid: network.bssid,
          ssid: network.ssid,
          channel: network.channel,
          wordlist: '/usr/share/wordlists/rockyou.txt',
          timeout: 3600
        })
      });

      const data = await response.json();
      setAttackResult(data);
      setAttackStatus('');
    } catch (error) {
      console.error('Full attack error:', error);
      setAttackStatus('');
      alert('Full attack failed');
    } finally {
      setIsAttacking(false);
    }
  };

  const getRiskColor = (riskLevel: string): string => {
    switch (riskLevel) {
      case 'Critical': return '#ef4444';
      case 'High': return '#f97316';
      case 'Medium': return '#eab308';
      case 'Low': return '#22c55e';
      default: return '#6b7280';
    }
  };

  const getSignalStrength = (signal: number): string => {
    if (signal >= -50) return 'Excellent';
    if (signal >= -60) return 'Good';
    if (signal >= -70) return 'Fair';
    return 'Weak';
  };

  if (!legalAcknowledged) {
    return (
      <div className="wifi-pentesting-panel">
        <div className="legal-warning">
          <h2>‚ö†Ô∏è LEGAL WARNING</h2>
          <div className="warning-content">
            <h3>WiFi Penetration Testing Module</h3>
            <p><strong>For authorized security testing only!</strong></p>

            <h4>Acceptable Use:</h4>
            <ul>
              <li>‚úÖ Testing networks you own</li>
              <li>‚úÖ Authorized penetration testing engagements</li>
              <li>‚úÖ CTF competitions and educational purposes</li>
              <li>‚úÖ Security research with proper authorization</li>
            </ul>

            <h4>Illegal Activities:</h4>
            <ul>
              <li>‚ùå Unauthorized access to networks</li>
              <li>‚ùå Testing neighbor's WiFi without permission</li>
              <li>‚ùå Corporate espionage</li>
              <li>‚ùå Malicious intent or data theft</li>
            </ul>

            <h4>Legal Consequences:</h4>
            <p>Unauthorized access can result in:</p>
            <ul>
              <li>Criminal prosecution</li>
              <li>Fines up to $250,000</li>
              <li>Prison sentences up to 10+ years</li>
              <li>Civil liability for damages</li>
            </ul>

            <p className="warning-emphasis">
              By proceeding, you acknowledge that you will only use this tool on networks
              you own or have explicit written authorization to test.
            </p>

            <button
              className="acknowledge-button"
              onClick={() => setLegalAcknowledged(true)}
            >
              I Acknowledge and Agree
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="wifi-pentesting-panel">
      <div className="panel-header">
        <h2>‚ö†Ô∏è WiFi Penetration Testing</h2>
        <p className="warning-text">For authorized security testing only!</p>

        {serverHealth && (
          <div className="server-status">
            <span className={`status-indicator ${serverHealth.status === 'ok' ? 'online' : 'offline'}`}>
              {serverHealth.status === 'ok' ? '‚óè Online' : '‚óè Offline'}
            </span>
            <span className="interface-info">
              Interface: {serverHealth.monitor_interface}
            </span>
          </div>
        )}
      </div>

      <div className="scan-section">
        <button
          className="scan-button"
          onClick={scanNetworks}
          disabled={isScanning}
        >
          {isScanning ? 'Scanning...' : 'üîç Scan Networks'}
        </button>

        {networks.length > 0 && (
          <p className="networks-found">{networks.length} networks found</p>
        )}
      </div>

      {networks.length > 0 && (
        <div className="networks-list">
          <h3>Discovered Networks</h3>
          {networks.map((network, index) => (
            <div
              key={index}
              className={`network-card ${selectedNetwork?.bssid === network.bssid ? 'selected' : ''}`}
              onClick={() => setSelectedNetwork(network)}
            >
              <div className="network-header">
                <div className="network-title">
                  <h4>{network.ssid || '[Hidden SSID]'}</h4>
                  <span className="bssid">{network.bssid}</span>
                </div>
                <div className="network-signal">
                  <span className="signal-strength">{network.signal_strength} dBm</span>
                  <span className="signal-quality">({getSignalStrength(network.signal_strength)})</span>
                </div>
              </div>

              <div className="network-details">
                <div className="detail-row">
                  <span>Channel: {network.channel}</span>
                  <span>Security: {network.security}</span>
                  <span>Encryption: {network.encryption}</span>
                  <span>WPS: {network.wps ? '‚úì Enabled' : '‚úó Disabled'}</span>
                  <span>Clients: {network.clients}</span>
                </div>

                <div className="security-analysis">
                  <div className="risk-level" style={{ color: getRiskColor(network.security_analysis.risk_level) }}>
                    Risk: {network.security_analysis.risk_level}
                  </div>

                  {network.security_analysis.vulnerabilities.length > 0 && (
                    <div className="vulnerabilities">
                      <strong>Vulnerabilities:</strong>
                      <ul>
                        {network.security_analysis.vulnerabilities.map((vuln, i) => (
                          <li key={i}>{vuln}</li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {network.security_analysis.recommendations.length > 0 && (
                    <div className="recommendations">
                      <strong>Recommendations:</strong>
                      <ul>
                        {network.security_analysis.recommendations.map((rec, i) => (
                          <li key={i}>{rec}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>

                {selectedNetwork?.bssid === network.bssid && (
                  <div className="attack-buttons">
                    <button
                      onClick={(e) => { e.stopPropagation(); testWPS(network); }}
                      disabled={isAttacking || !network.wps}
                      className="attack-button wps"
                      title={network.wps ? 'Test WPS vulnerability' : 'WPS not enabled'}
                    >
                      üéØ Test WPS
                    </button>

                    <button
                      onClick={(e) => { e.stopPropagation(); captureHandshake(network); }}
                      disabled={isAttacking || network.security === 'Open'}
                      className="attack-button handshake"
                      title="Capture WPA handshake"
                    >
                      üì° Capture Handshake
                    </button>

                    <button
                      onClick={(e) => { e.stopPropagation(); fullAttack(network); }}
                      disabled={isAttacking}
                      className="attack-button full"
                      title="Full automated attack"
                    >
                      ‚ö° Full Attack
                    </button>
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      )}

      {attackStatus && (
        <div className="attack-status">
          <div className="spinner"></div>
          <p>{attackStatus}</p>
        </div>
      )}

      {attackResult && (
        <div className={`attack-result ${attackResult.success ? 'success' : 'failure'}`}>
          <h3>{attackResult.success ? '‚úì Attack Successful!' : '‚úó Attack Failed'}</h3>

          {attackResult.success && attackResult.password && (
            <div className="result-details">
              <div className="password-found">
                <strong>Password:</strong>
                <span className="password">{attackResult.password}</span>
              </div>

              {attackResult.wps_pin && (
                <div className="wps-pin">
                  <strong>WPS PIN:</strong>
                  <span>{attackResult.wps_pin}</span>
                </div>
              )}

              {attackResult.method && (
                <div className="method">
                  <strong>Method:</strong> {attackResult.method.replace(/_/g, ' ').toUpperCase()}
                </div>
              )}

              {attackResult.duration && (
                <div className="duration">
                  <strong>Duration:</strong> {attackResult.duration.toFixed(1)}s
                </div>
              )}
            </div>
          )}

          {!attackResult.success && attackResult.error && (
            <div className="error-message">
              <p>{attackResult.error}</p>
            </div>
          )}

          {attackResult.attempts && attackResult.attempts.length > 0 && (
            <div className="attack-attempts">
              <h4>Attack Attempts:</h4>
              <ul>
                {attackResult.attempts.map((attempt: any, i: number) => (
                  <li key={i}>
                    <strong>{attempt.method.replace(/_/g, ' ')}:</strong> {attempt.status}
                    {attempt.duration && ` (${attempt.duration.toFixed(1)}s)`}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      )}

      <div className="panel-footer">
        <p className="disclaimer">
          ‚ö†Ô∏è Only use on networks you own or have written authorization to test.
          Unauthorized access is illegal and unethical.
        </p>
      </div>
    </div>
  );
};

export default WiFiPentestingPanel;
