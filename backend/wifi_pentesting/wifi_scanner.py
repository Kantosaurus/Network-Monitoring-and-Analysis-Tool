"""
WiFi Network Scanner

For authorized security testing only!
Scans for WiFi networks and analyzes security configurations.

Similar to: airodump-ng, Kismet, inSSIDer
"""

import subprocess
import re
import time
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum
import platform
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class SecurityType(Enum):
    """WiFi security types"""
    OPEN = "Open"
    WEP = "WEP"
    WPA = "WPA"
    WPA2 = "WPA2"
    WPA3 = "WPA3"
    WPA_WPA2 = "WPA/WPA2"
    UNKNOWN = "Unknown"


@dataclass
class WiFiNetwork:
    """WiFi network information"""
    ssid: str
    bssid: str  # MAC address of AP
    channel: int
    signal_strength: int  # dBm
    security: SecurityType
    encryption: str  # TKIP, CCMP, etc.
    wps: bool  # WPS enabled
    clients: int  # Number of connected clients
    vendor: Optional[str] = None  # AP manufacturer


class WiFiScanner:
    """
    WiFi Network Scanner

    Discovers WiFi networks and analyzes security configurations.
    For authorized security testing only!
    """

    def __init__(self, interface: str = "wlan0", monitor_mode: bool = False):
        """
        Initialize WiFi scanner

        Args:
            interface: Network interface to use (wlan0, wlan1, etc.)
            monitor_mode: Whether to enable monitor mode

        ⚠️ WARNING: Only scan networks you have authorization to test!
        """
        self.interface = interface
        self.monitor_mode = monitor_mode
        self.os_type = platform.system()

        # Check authorization
        self._check_authorization()

        # Initialize interface
        if monitor_mode:
            self._enable_monitor_mode()

    def _check_authorization(self):
        """Verify user has acknowledged legal warning"""
        import os
        if not os.environ.get('WIFI_PENTEST_ACKNOWLEDGED'):
            raise PermissionError(
                "⚠️ You must acknowledge the legal warning before using this tool.\n"
                "See LEGAL_WARNING.md and set WIFI_PENTEST_ACKNOWLEDGED=1"
            )

    def _enable_monitor_mode(self):
        """Enable monitor mode on network interface"""
        logger.info(f"Enabling monitor mode on {self.interface}")

        if self.os_type == "Linux":
            try:
                # Using airmon-ng (if available)
                subprocess.run(['airmon-ng', 'check', 'kill'], check=True)
                subprocess.run(['airmon-ng', 'start', self.interface], check=True)
                self.interface = self.interface + 'mon'  # Interface renamed
                logger.info(f"Monitor mode enabled: {self.interface}")
            except FileNotFoundError:
                logger.warning("airmon-ng not found. Trying iwconfig...")
                # Fallback to iwconfig
                subprocess.run(['ifconfig', self.interface, 'down'], check=True)
                subprocess.run(['iwconfig', self.interface, 'mode', 'monitor'], check=True)
                subprocess.run(['ifconfig', self.interface, 'up'], check=True)
        elif self.os_type == "Windows":
            logger.warning("Monitor mode on Windows requires specialized drivers")
            logger.info("Consider using: Acrylic WiFi, CommView, or WinPcap with AirPcap")
        else:
            logger.warning(f"Monitor mode on {self.os_type} not fully supported")

    def scan_networks(self, duration: int = 10) -> List[WiFiNetwork]:
        """
        Scan for WiFi networks

        Args:
            duration: Scan duration in seconds

        Returns:
            List of discovered networks

        ⚠️ WARNING: Only scan networks you have authorization to test!
        """
        logger.info(f"Scanning for WiFi networks (duration: {duration}s)...")

        if self.os_type == "Linux":
            return self._scan_linux(duration)
        elif self.os_type == "Windows":
            return self._scan_windows()
        else:
            logger.error(f"Unsupported OS: {self.os_type}")
            return []

    def _scan_linux(self, duration: int) -> List[WiFiNetwork]:
        """Scan networks on Linux"""
        networks = []

        try:
            if self.monitor_mode:
                # Use airodump-ng for detailed scanning
                output_file = "/tmp/scan_output"
                cmd = [
                    'airodump-ng',
                    '--write', output_file,
                    '--output-format', 'csv',
                    '--write-interval', '1',
                    self.interface
                ]

                # Run for specified duration
                proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                time.sleep(duration)
                proc.terminate()

                # Parse output
                networks = self._parse_airodump_csv(output_file + '-01.csv')

            else:
                # Use iwlist for basic scanning
                result = subprocess.run(
                    ['iwlist', self.interface, 'scan'],
                    capture_output=True,
                    text=True,
                    check=True
                )

                networks = self._parse_iwlist_output(result.stdout)

        except Exception as e:
            logger.error(f"Scan error: {e}")

        return networks

    def _scan_windows(self) -> List[WiFiNetwork]:
        """Scan networks on Windows"""
        networks = []

        try:
            # Use netsh to scan
            result = subprocess.run(
                ['netsh', 'wlan', 'show', 'networks', 'mode=bssid'],
                capture_output=True,
                text=True,
                check=True
            )

            networks = self._parse_netsh_output(result.stdout)

        except Exception as e:
            logger.error(f"Scan error: {e}")

        return networks

    def _parse_airodump_csv(self, filepath: str) -> List[WiFiNetwork]:
        """Parse airodump-ng CSV output"""
        networks = []

        try:
            with open(filepath, 'r') as f:
                lines = f.readlines()

            # Find AP section
            for i, line in enumerate(lines):
                if line.startswith('BSSID'):
                    # Parse APs
                    for ap_line in lines[i+1:]:
                        if ap_line.strip() == '':
                            break

                        parts = ap_line.split(',')
                        if len(parts) >= 14:
                            network = WiFiNetwork(
                                ssid=parts[13].strip(),
                                bssid=parts[0].strip(),
                                channel=int(parts[3].strip()) if parts[3].strip().isdigit() else 0,
                                signal_strength=int(parts[8].strip()) if parts[8].strip().lstrip('-').isdigit() else -100,
                                security=self._parse_security(parts[5].strip()),
                                encryption=parts[5].strip(),
                                wps=False,  # Would need additional detection
                                clients=int(parts[10].strip()) if parts[10].strip().isdigit() else 0
                            )
                            networks.append(network)
                    break

        except Exception as e:
            logger.error(f"Error parsing airodump CSV: {e}")

        return networks

    def _parse_iwlist_output(self, output: str) -> List[WiFiNetwork]:
        """Parse iwlist scan output"""
        networks = []
        current_network = {}

        for line in output.split('\n'):
            line = line.strip()

            if 'Address:' in line:
                if current_network:
                    networks.append(self._dict_to_network(current_network))
                    current_network = {}
                current_network['bssid'] = line.split('Address: ')[1]

            elif 'ESSID:' in line:
                ssid = re.search(r'ESSID:"(.+)"', line)
                current_network['ssid'] = ssid.group(1) if ssid else ''

            elif 'Channel:' in line:
                channel = re.search(r'Channel:(\d+)', line)
                current_network['channel'] = int(channel.group(1)) if channel else 0

            elif 'Signal level=' in line:
                signal = re.search(r'Signal level=(-?\d+)', line)
                current_network['signal'] = int(signal.group(1)) if signal else -100

            elif 'Encryption key:' in line:
                current_network['encryption'] = 'on' if 'on' in line else 'off'

            elif 'WPA' in line or 'WPA2' in line:
                current_network['wpa'] = True

        if current_network:
            networks.append(self._dict_to_network(current_network))

        return networks

    def _parse_netsh_output(self, output: str) -> List[WiFiNetwork]:
        """Parse Windows netsh output"""
        networks = []
        current_network = {}

        for line in output.split('\n'):
            line = line.strip()

            if line.startswith('SSID'):
                if current_network:
                    networks.append(self._dict_to_network(current_network))
                    current_network = {}
                ssid = line.split(':', 1)[1].strip()
                current_network['ssid'] = ssid

            elif 'BSSID' in line and ':' in line:
                bssid = line.split(':', 1)[1].strip()
                current_network['bssid'] = bssid

            elif 'Signal' in line:
                signal = re.search(r'(\d+)%', line)
                if signal:
                    # Convert percentage to dBm (approximate)
                    percent = int(signal.group(1))
                    dbm = int((percent / 2) - 100)
                    current_network['signal'] = dbm

            elif 'Authentication' in line:
                auth = line.split(':', 1)[1].strip()
                current_network['auth'] = auth

            elif 'Channel' in line:
                channel = re.search(r'(\d+)', line)
                current_network['channel'] = int(channel.group(1)) if channel else 0

        if current_network:
            networks.append(self._dict_to_network(current_network))

        return networks

    def _dict_to_network(self, data: dict) -> WiFiNetwork:
        """Convert dict to WiFiNetwork object"""
        return WiFiNetwork(
            ssid=data.get('ssid', ''),
            bssid=data.get('bssid', ''),
            channel=data.get('channel', 0),
            signal_strength=data.get('signal', -100),
            security=self._parse_security(data.get('auth', '')),
            encryption=data.get('auth', 'Unknown'),
            wps=False,
            clients=0
        )

    def _parse_security(self, security_string: str) -> SecurityType:
        """Parse security type from string"""
        security_string = security_string.upper()

        if 'WPA3' in security_string:
            return SecurityType.WPA3
        elif 'WPA2' in security_string:
            return SecurityType.WPA2
        elif 'WPA' in security_string:
            if 'WPA2' in security_string:
                return SecurityType.WPA_WPA2
            return SecurityType.WPA
        elif 'WEP' in security_string:
            return SecurityType.WEP
        elif 'OPEN' in security_string or security_string == '':
            return SecurityType.OPEN
        else:
            return SecurityType.UNKNOWN

    def analyze_security(self, network: WiFiNetwork) -> Dict[str, any]:
        """
        Analyze network security posture

        Args:
            network: WiFi network to analyze

        Returns:
            Security analysis results
        """
        analysis = {
            'network': network.ssid,
            'bssid': network.bssid,
            'vulnerabilities': [],
            'recommendations': [],
            'risk_level': 'Low'
        }

        # Check for weak security
        if network.security == SecurityType.OPEN:
            analysis['vulnerabilities'].append("No encryption - all traffic is visible")
            analysis['recommendations'].append("Enable WPA2 or WPA3 encryption")
            analysis['risk_level'] = 'Critical'

        elif network.security == SecurityType.WEP:
            analysis['vulnerabilities'].append("WEP is broken and easily cracked")
            analysis['recommendations'].append("Upgrade to WPA2 or WPA3 immediately")
            analysis['risk_level'] = 'Critical'

        elif network.security == SecurityType.WPA:
            analysis['vulnerabilities'].append("WPA is deprecated and has known vulnerabilities")
            analysis['recommendations'].append("Upgrade to WPA2 or WPA3")
            analysis['risk_level'] = 'High'

        elif network.security == SecurityType.WPA2:
            if network.wps:
                analysis['vulnerabilities'].append("WPS enabled - vulnerable to brute force")
                analysis['recommendations'].append("Disable WPS")
                analysis['risk_level'] = 'Medium'
            else:
                analysis['risk_level'] = 'Low'
                analysis['recommendations'].append("Consider upgrading to WPA3 for better security")

        return analysis

    def export_results(self, networks: List[WiFiNetwork], filepath: str):
        """Export scan results to file"""
        with open(filepath, 'w') as f:
            f.write("SSID,BSSID,Channel,Signal,Security,Encryption,WPS,Clients\n")
            for net in networks:
                f.write(f"{net.ssid},{net.bssid},{net.channel},{net.signal_strength},"
                       f"{net.security.value},{net.encryption},{net.wps},{net.clients}\n")

        logger.info(f"Results exported to {filepath}")


# Example usage
if __name__ == "__main__":
    # Set authorization acknowledgment
    import os
    os.environ['WIFI_PENTEST_ACKNOWLEDGED'] = '1'

    print("\n⚠️  AUTHORIZED SECURITY TESTING ONLY ⚠️\n")
    print("Ensure you have written authorization to scan these networks!\n")

    scanner = WiFiScanner(interface="wlan0", monitor_mode=False)
    networks = scanner.scan_networks(duration=10)

    print(f"\nFound {len(networks)} networks:\n")
    for net in networks:
        print(f"SSID: {net.ssid:30} | Signal: {net.signal_strength:4} dBm | "
              f"Security: {net.security.value:10} | Channel: {net.channel}")

        # Security analysis
        analysis = scanner.analyze_security(net)
        if analysis['vulnerabilities']:
            print(f"  ⚠️  Risk: {analysis['risk_level']}")
            for vuln in analysis['vulnerabilities']:
                print(f"      - {vuln}")
