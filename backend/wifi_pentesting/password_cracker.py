"""
WPA/WPA2 Password Cracker

For authorized security testing only!
Integrates with hashcat and john the ripper for password cracking.

Similar to: hashcat, john the ripper, aircrack-ng
"""

import subprocess
import time
import re
import os
from typing import Optional, Dict, List
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CrackerType(Enum):
    """Password cracker types"""
    HASHCAT = "hashcat"
    JOHN = "john"
    AIRCRACK = "aircrack-ng"


class AttackMode(Enum):
    """Password attack modes"""
    DICTIONARY = "dictionary"  # Wordlist attack
    BRUTE_FORCE = "brute_force"  # Exhaustive search
    HYBRID = "hybrid"  # Wordlist + rules
    MASK = "mask"  # Mask attack (e.g., ?d?d?d?d)


class CrackStatus(Enum):
    """Cracking status"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    SUCCESS = "success"
    EXHAUSTED = "exhausted"  # All options tried
    FAILED = "failed"


@dataclass
class CrackResult:
    """Password cracking result"""
    status: CrackStatus
    ssid: str
    bssid: str
    password: Optional[str] = None
    cracker: Optional[CrackerType] = None
    attack_mode: Optional[AttackMode] = None
    duration: Optional[float] = None
    attempts: int = 0
    hash_rate: Optional[float] = None  # Hashes per second


class PasswordCracker:
    """
    WPA/WPA2 Password Cracker

    Integrates with hashcat, john, and aircrack-ng for password cracking.
    For authorized security testing only!
    """

    def __init__(self, wordlist_dir: str = "/usr/share/wordlists"):
        """
        Initialize password cracker

        Args:
            wordlist_dir: Directory containing wordlists

        ⚠️ WARNING: Only crack passwords from networks you have authorization to test!
        """
        self.wordlist_dir = Path(wordlist_dir)

        # Check authorization
        self._check_authorization()

        # Check available tools
        self.available_tools = self._check_tools()
        logger.info(f"Available crackers: {', '.join(self.available_tools)}")

        # Find wordlists
        self.wordlists = self._find_wordlists()
        logger.info(f"Found {len(self.wordlists)} wordlists")

    def _check_authorization(self):
        """Verify user has acknowledged legal warning"""
        if not os.environ.get('WIFI_PENTEST_ACKNOWLEDGED'):
            raise PermissionError(
                "⚠️ You must acknowledge the legal warning before using this tool.\n"
                "See LEGAL_WARNING.md and set WIFI_PENTEST_ACKNOWLEDGED=1"
            )

    def _check_tools(self) -> List[str]:
        """Check which cracking tools are available"""
        tools = []

        for tool in ['hashcat', 'john', 'aircrack-ng']:
            try:
                subprocess.run(
                    [tool, '--version'],
                    capture_output=True,
                    check=False,
                    timeout=5
                )
                tools.append(tool)
            except (FileNotFoundError, subprocess.TimeoutExpired):
                pass

        return tools

    def _find_wordlists(self) -> List[Path]:
        """Find available wordlists"""
        wordlists = []

        if not self.wordlist_dir.exists():
            logger.warning(f"Wordlist directory not found: {self.wordlist_dir}")
            return wordlists

        # Common wordlist patterns
        patterns = ['*.txt', '*.lst', '*.dict', '*.wordlist']

        for pattern in patterns:
            wordlists.extend(self.wordlist_dir.rglob(pattern))

        # Add rockyou if exists
        rockyou = Path('/usr/share/wordlists/rockyou.txt')
        if rockyou.exists() and rockyou not in wordlists:
            wordlists.append(rockyou)

        return wordlists

    def crack_password(
        self,
        capture_file: str,
        ssid: str,
        bssid: str,
        wordlist: Optional[str] = None,
        cracker: Optional[CrackerType] = None,
        attack_mode: AttackMode = AttackMode.DICTIONARY,
        timeout: Optional[int] = None
    ) -> CrackResult:
        """
        Crack WPA/WPA2 password

        Args:
            capture_file: Path to capture file (.cap or .hccapx)
            ssid: Target network SSID
            bssid: Target BSSID
            wordlist: Path to wordlist (None for default)
            cracker: Cracker to use (None for auto)
            attack_mode: Attack mode
            timeout: Timeout in seconds

        Returns:
            CrackResult with password if successful

        ⚠️ WARNING: Only crack passwords from networks you have authorization to test!
        """
        logger.info(f"Starting password cracking for {ssid} ({bssid})")
        logger.info(f"Capture file: {capture_file}")
        logger.info(f"Attack mode: {attack_mode.value}")

        # Choose wordlist
        if wordlist is None:
            wordlist = self._choose_wordlist()
            if wordlist is None:
                logger.error("No wordlist available")
                return CrackResult(
                    status=CrackStatus.FAILED,
                    ssid=ssid,
                    bssid=bssid
                )

        logger.info(f"Using wordlist: {wordlist}")

        # Choose cracker
        if cracker is None:
            cracker = self._choose_cracker()

        logger.info(f"Using cracker: {cracker.value}")

        # Crack based on tool
        if cracker == CrackerType.HASHCAT:
            return self._crack_with_hashcat(
                capture_file, ssid, bssid, wordlist, attack_mode, timeout
            )
        elif cracker == CrackerType.JOHN:
            return self._crack_with_john(
                capture_file, ssid, bssid, wordlist, attack_mode, timeout
            )
        elif cracker == CrackerType.AIRCRACK:
            return self._crack_with_aircrack(
                capture_file, ssid, bssid, wordlist, timeout
            )
        else:
            logger.error("No cracker available")
            return CrackResult(
                status=CrackStatus.FAILED,
                ssid=ssid,
                bssid=bssid
            )

    def _choose_wordlist(self) -> Optional[str]:
        """Choose best available wordlist"""
        # Prefer rockyou.txt
        rockyou = Path('/usr/share/wordlists/rockyou.txt')
        if rockyou.exists():
            return str(rockyou)

        # Use first available
        if self.wordlists:
            return str(self.wordlists[0])

        return None

    def _choose_cracker(self) -> CrackerType:
        """Choose best available cracker"""
        # Prefer hashcat (fastest with GPU)
        if 'hashcat' in self.available_tools:
            return CrackerType.HASHCAT
        elif 'aircrack-ng' in self.available_tools:
            return CrackerType.AIRCRACK
        elif 'john' in self.available_tools:
            return CrackerType.JOHN
        else:
            raise RuntimeError("No password cracker available")

    def _crack_with_hashcat(
        self,
        capture_file: str,
        ssid: str,
        bssid: str,
        wordlist: str,
        attack_mode: AttackMode,
        timeout: Optional[int]
    ) -> CrackResult:
        """
        Crack with hashcat (GPU-accelerated)

        Hashcat is the fastest cracker with GPU support
        """
        logger.info("Cracking with hashcat...")

        # Convert to hccapx if needed
        if capture_file.endswith('.cap'):
            hccapx_file = capture_file.replace('.cap', '.hccapx')
            if not self._convert_to_hccapx(capture_file, hccapx_file):
                logger.error("Failed to convert to hccapx format")
                return CrackResult(
                    status=CrackStatus.FAILED,
                    ssid=ssid,
                    bssid=bssid,
                    cracker=CrackerType.HASHCAT
                )
            capture_file = hccapx_file

        start_time = time.time()

        try:
            # Hashcat command
            # -m 2500 = WPA/WPA2
            # -a 0 = Dictionary attack
            # -o = Output file
            # --status = Show status
            output_file = capture_file + '.out'

            cmd = [
                'hashcat',
                '-m', '2500',  # WPA/WPA2
                '-a', '0' if attack_mode == AttackMode.DICTIONARY else '3',
                capture_file,
                wordlist,
                '-o', output_file,
                '--status',
                '--status-timer', '10'
            ]

            # Add options based on attack mode
            if attack_mode == AttackMode.HYBRID:
                cmd.extend(['-r', 'rules/best64.rule'])

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )

            # Monitor progress
            hash_rate = 0
            attempts = 0

            while True:
                line = proc.stdout.readline()
                if not line:
                    break

                logger.debug(line.strip())

                # Parse hash rate
                rate_match = re.search(r'Speed\.\w+\.:\s*([\d.]+)\s*(\w+)', line)
                if rate_match:
                    rate = float(rate_match.group(1))
                    unit = rate_match.group(2)
                    # Convert to H/s
                    if 'kH/s' in unit:
                        rate *= 1000
                    elif 'MH/s' in unit:
                        rate *= 1000000
                    hash_rate = rate

                # Parse progress
                progress_match = re.search(r'Progress\.+:\s*(\d+)', line)
                if progress_match:
                    attempts = int(progress_match.group(1))

                # Check timeout
                if timeout and time.time() - start_time > timeout:
                    logger.warning("Hashcat timed out")
                    proc.terminate()
                    break

            proc.wait(timeout=10)
            duration = time.time() - start_time

            # Check for cracked password
            if os.path.exists(output_file):
                with open(output_file, 'r') as f:
                    content = f.read()
                    # Format: hash:password
                    match = re.search(r':(.+)$', content, re.MULTILINE)
                    if match:
                        password = match.group(1).strip()
                        logger.info(f"✓ Password cracked: {password}")
                        return CrackResult(
                            status=CrackStatus.SUCCESS,
                            ssid=ssid,
                            bssid=bssid,
                            password=password,
                            cracker=CrackerType.HASHCAT,
                            attack_mode=attack_mode,
                            duration=duration,
                            attempts=attempts,
                            hash_rate=hash_rate
                        )

            # Not cracked
            logger.info("Hashcat exhausted wordlist without finding password")
            return CrackResult(
                status=CrackStatus.EXHAUSTED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.HASHCAT,
                attack_mode=attack_mode,
                duration=duration,
                attempts=attempts,
                hash_rate=hash_rate
            )

        except Exception as e:
            logger.error(f"Hashcat error: {e}")
            return CrackResult(
                status=CrackStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.HASHCAT
            )

    def _crack_with_aircrack(
        self,
        capture_file: str,
        ssid: str,
        bssid: str,
        wordlist: str,
        timeout: Optional[int]
    ) -> CrackResult:
        """
        Crack with aircrack-ng

        Slower than hashcat but doesn't require GPU
        """
        logger.info("Cracking with aircrack-ng...")

        start_time = time.time()

        try:
            cmd = [
                'aircrack-ng',
                '-w', wordlist,
                '-b', bssid,
                capture_file
            ]

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )

            # Monitor output
            attempts = 0
            password = None

            while True:
                line = proc.stdout.readline()
                if not line:
                    break

                logger.debug(line.strip())

                # Parse attempts
                attempts_match = re.search(r'Tested\s+(\d+)', line)
                if attempts_match:
                    attempts = int(attempts_match.group(1))
                    if attempts % 10000 == 0:
                        logger.info(f"Tested {attempts} keys...")

                # Check for password
                key_match = re.search(r'KEY FOUND!\s*\[\s*(.+?)\s*\]', line, re.IGNORECASE)
                if key_match:
                    password = key_match.group(1).strip()
                    logger.info(f"✓ Password found: {password}")

                # Check timeout
                if timeout and time.time() - start_time > timeout:
                    logger.warning("Aircrack-ng timed out")
                    proc.terminate()
                    break

            proc.wait(timeout=10)
            duration = time.time() - start_time

            if password:
                return CrackResult(
                    status=CrackStatus.SUCCESS,
                    ssid=ssid,
                    bssid=bssid,
                    password=password,
                    cracker=CrackerType.AIRCRACK,
                    attack_mode=AttackMode.DICTIONARY,
                    duration=duration,
                    attempts=attempts
                )
            else:
                logger.info("Aircrack-ng exhausted wordlist without finding password")
                return CrackResult(
                    status=CrackStatus.EXHAUSTED,
                    ssid=ssid,
                    bssid=bssid,
                    cracker=CrackerType.AIRCRACK,
                    attack_mode=AttackMode.DICTIONARY,
                    duration=duration,
                    attempts=attempts
                )

        except Exception as e:
            logger.error(f"Aircrack-ng error: {e}")
            return CrackResult(
                status=CrackStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.AIRCRACK
            )

    def _crack_with_john(
        self,
        capture_file: str,
        ssid: str,
        bssid: str,
        wordlist: str,
        attack_mode: AttackMode,
        timeout: Optional[int]
    ) -> CrackResult:
        """
        Crack with John the Ripper

        Alternative cracker with good rule support
        """
        logger.info("Cracking with John the Ripper...")

        # Convert to john format if needed
        john_file = capture_file + '.john'
        if not self._convert_to_john(capture_file, john_file):
            logger.error("Failed to convert to john format")
            return CrackResult(
                status=CrackStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.JOHN
            )

        start_time = time.time()

        try:
            cmd = [
                'john',
                '--wordlist=' + wordlist,
                john_file
            ]

            # Add options based on attack mode
            if attack_mode == AttackMode.HYBRID:
                cmd.append('--rules')

            logger.info(f"Running: {' '.join(cmd)}")

            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            duration = time.time() - start_time

            # Check for cracked password
            show_cmd = ['john', '--show', john_file]
            show_result = subprocess.run(
                show_cmd,
                capture_output=True,
                text=True,
                timeout=10
            )

            # Parse output
            password_match = re.search(r':(.+?):', show_result.stdout)
            if password_match:
                password = password_match.group(1).strip()
                logger.info(f"✓ Password cracked: {password}")
                return CrackResult(
                    status=CrackStatus.SUCCESS,
                    ssid=ssid,
                    bssid=bssid,
                    password=password,
                    cracker=CrackerType.JOHN,
                    attack_mode=attack_mode,
                    duration=duration
                )
            else:
                return CrackResult(
                    status=CrackStatus.EXHAUSTED,
                    ssid=ssid,
                    bssid=bssid,
                    cracker=CrackerType.JOHN,
                    attack_mode=attack_mode,
                    duration=duration
                )

        except subprocess.TimeoutExpired:
            logger.warning("John the Ripper timed out")
            duration = time.time() - start_time
            return CrackResult(
                status=CrackStatus.EXHAUSTED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.JOHN,
                attack_mode=attack_mode,
                duration=duration
            )
        except Exception as e:
            logger.error(f"John the Ripper error: {e}")
            return CrackResult(
                status=CrackStatus.FAILED,
                ssid=ssid,
                bssid=bssid,
                cracker=CrackerType.JOHN
            )

    def _convert_to_hccapx(self, cap_file: str, hccapx_file: str) -> bool:
        """Convert .cap to .hccapx for hashcat"""
        try:
            # Try hcxpcapngtool (newer)
            result = subprocess.run(
                ['hcxpcapngtool', '-o', hccapx_file, cap_file],
                capture_output=True,
                check=False
            )
            if result.returncode == 0:
                return True

            # Fallback to cap2hccapx
            result = subprocess.run(
                ['cap2hccapx', cap_file, hccapx_file],
                capture_output=True,
                check=False
            )
            return result.returncode == 0

        except FileNotFoundError:
            logger.error("Conversion tool not found")
            return False

    def _convert_to_john(self, cap_file: str, john_file: str) -> bool:
        """Convert .cap to john format"""
        try:
            result = subprocess.run(
                ['wpapcap2john', cap_file],
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode == 0:
                with open(john_file, 'w') as f:
                    f.write(result.stdout)
                return True

            return False

        except FileNotFoundError:
            logger.error("wpapcap2john not found")
            return False

    def estimate_time(
        self,
        wordlist: str,
        hash_rate: Optional[float] = None
    ) -> Dict[str, float]:
        """
        Estimate cracking time

        Args:
            wordlist: Path to wordlist
            hash_rate: Hashes per second (None for auto-detect)

        Returns:
            Dictionary with time estimates
        """
        # Count words in wordlist
        try:
            result = subprocess.run(
                ['wc', '-l', wordlist],
                capture_output=True,
                text=True,
                check=True
            )
            word_count = int(result.stdout.split()[0])
        except:
            word_count = 0

        # Estimate hash rate if not provided
        if hash_rate is None:
            # Typical rates:
            # CPU: 1000-10000 H/s
            # GPU (single): 100000-1000000 H/s
            # GPU (multi): 1000000+ H/s
            hash_rate = 10000  # Conservative CPU estimate

        # Calculate time
        if hash_rate > 0:
            seconds = word_count / hash_rate
            minutes = seconds / 60
            hours = minutes / 60
            days = hours / 24

            return {
                'word_count': word_count,
                'hash_rate': hash_rate,
                'seconds': seconds,
                'minutes': minutes,
                'hours': hours,
                'days': days
            }

        return {}


# Example usage
if __name__ == "__main__":
    import os
    os.environ['WIFI_PENTEST_ACKNOWLEDGED'] = '1'

    print("\n⚠️  AUTHORIZED SECURITY TESTING ONLY ⚠️\n")
    print("Ensure you have written authorization to crack this password!\n")

    # Example: Crack password
    cracker = PasswordCracker(wordlist_dir="/usr/share/wordlists")

    # Handshake capture file
    capture_file = "/tmp/handshakes/handshake_TestNetwork_1234567890-01.cap"
    ssid = "TestNetwork"
    bssid = "00:11:22:33:44:55"

    # Estimate time
    wordlist = "/usr/share/wordlists/rockyou.txt"
    estimate = cracker.estimate_time(wordlist, hash_rate=100000)
    print(f"Estimated time with {estimate.get('word_count', 0)} words:")
    print(f"  {estimate.get('hours', 0):.1f} hours")
    print(f"  {estimate.get('days', 0):.1f} days")
    print()

    # Crack password
    print("=== Starting Password Cracking ===")
    result = cracker.crack_password(
        capture_file=capture_file,
        ssid=ssid,
        bssid=bssid,
        wordlist=wordlist,
        attack_mode=AttackMode.DICTIONARY,
        timeout=3600  # 1 hour
    )

    if result.status == CrackStatus.SUCCESS:
        print(f"\n✓ Password cracked successfully!")
        print(f"  SSID: {result.ssid}")
        print(f"  Password: {result.password}")
        print(f"  Duration: {result.duration:.1f}s")
        print(f"  Attempts: {result.attempts}")
        if result.hash_rate:
            print(f"  Hash rate: {result.hash_rate:.0f} H/s")
    else:
        print(f"\n✗ Password cracking failed: {result.status.value}")
